"""
DIGITAL DAIMON - Testes End-to-End Completos
==============================================

Testes E2E que validam toda a stack funcionando:
- Backend (FastAPI) em localhost:8001
- Frontend (Next.js) em localhost:3000  
- Sincronização Kuramoto (ESGT/TIG)
- SSE Streaming
- UI responsiveness

Autor: Claude (Copilot CLI)
Data: 2025-12-06
Base: Auditoria exploratória completa
"""

import asyncio
import json
import sys
import time
from typing import Any

import httpx
import pytest
import pytest_asyncio


# ============================================================================
# CONFIGURAÇÃO
# ============================================================================

BACKEND_URL = "http://localhost:8001"
FRONTEND_URL = "http://localhost:3000"
TIMEOUT = 30.0


# ============================================================================
# FIXTURES
# ============================================================================

@pytest_asyncio.fixture
async def backend_client():
    """HTTP client for backend."""
    async with httpx.AsyncClient(base_url=BACKEND_URL, timeout=TIMEOUT) as client:
        yield client


@pytest_asyncio.fixture
async def frontend_client():
    """HTTP client for frontend."""
    async with httpx.AsyncClient(base_url=FRONTEND_URL, timeout=TIMEOUT) as client:
        yield client


# ============================================================================
# TIER 1: SMOKE TESTS - Sistema Básico Funcionando
# ============================================================================

class TestTier1Smoke:
    """Smoke tests - Validar que serviços estão no ar."""
    
    @pytest.mark.asyncio
    async def test_backend_is_alive(self, backend_client: httpx.AsyncClient):
        """Backend responde na porta 8001."""
        response = await backend_client.get("/")
        assert response.status_code == 200
        data = response.json()
        assert "service" in data
        assert "maximus-core-service" in data["service"]
        print("✅ Backend está vivo")
    
    @pytest.mark.asyncio
    async def test_backend_health_check(self, backend_client: httpx.AsyncClient):
        """Health check do backend retorna healthy."""
        response = await backend_client.get("/v1/health")
        assert response.status_code == 200
        data = response.json()
        assert data["status"] == "healthy"
        print("✅ Backend health check OK")
    
    @pytest.mark.asyncio
    async def test_frontend_is_alive(self, frontend_client: httpx.AsyncClient):
        """Frontend responde na porta 3000."""
        try:
            response = await frontend_client.get("/")
            assert response.status_code == 200
            # Next.js retorna HTML
            assert "html" in response.text.lower() or "<!DOCTYPE" in response.text
            print("✅ Frontend está vivo")
        except httpx.ConnectError:
            pytest.skip("Frontend não está rodando em localhost:3000")
    
    @pytest.mark.asyncio
    async def test_openapi_docs_available(self, backend_client: httpx.AsyncClient):
        """OpenAPI docs estão acessíveis."""
        response = await backend_client.get("/openapi.json")
        assert response.status_code == 200
        data = response.json()
        assert "openapi" in data
        assert "paths" in data
        print(f"✅ OpenAPI docs OK ({len(data['paths'])} endpoints)")


# ============================================================================
# TIER 2: CONSCIOUSNESS SYSTEM - Componentes Internos
# ============================================================================

class TestTier2Consciousness:
    """Testes do sistema de consciência (componentes internos)."""
    
    @pytest.mark.asyncio
    async def test_consciousness_metrics_endpoint(self, backend_client: httpx.AsyncClient):
        """Endpoint de métricas retorna dados."""
        response = await backend_client.get("/api/consciousness/metrics")
        assert response.status_code == 200
        data = response.json()
        assert "events_count" in data
        assert "timestamp" in data
        print(f"✅ Metrics endpoint OK (events: {data['events_count']})")


# ============================================================================
# TIER 3: SSE STREAMING - Comunicação Tempo Real
# ============================================================================

class TestTier3SSEStreaming:
    """Testes de streaming via Server-Sent Events."""
    
    @pytest.mark.asyncio
    async def test_sse_connection_establishment(self, backend_client: httpx.AsyncClient):
        """Conectar ao SSE /stream/sse e receber heartbeat."""
        url = "/api/consciousness/stream/sse"
        
        received_events = []
        connection_ack = False
        
        async with backend_client.stream("GET", url) as response:
            assert response.status_code == 200
            assert "text/event-stream" in response.headers["content-type"]
            
            # Ler primeiros eventos (timeout 5s)
            start_time = time.time()
            async for line in response.aiter_lines():
                if time.time() - start_time > 5:
                    break
                
                if line.startswith("data: "):
                    data_str = line[6:]
                    try:
                        event = json.loads(data_str)
                        received_events.append(event)
                        
                        if event.get("type") == "connection_ack":
                            connection_ack = True
                            break
                    except json.JSONDecodeError:
                        pass
        
        assert connection_ack, "Não recebeu connection_ack"
        print(f"✅ SSE connection OK ({len(received_events)} eventos)")


# ============================================================================
# MAIN - Executar todos os testes
# ============================================================================

if __name__ == "__main__":
    """
    Executar com:
        pytest tests/e2e/test_full_stack_e2e.py -v -s
    """
    import sys
    sys.exit(pytest.main([__file__, "-v", "-s"]))
