"""
Active Journaling Service - The Writer of Souls.

Maintains 'gemini.md' and 'claude.md' at project root as living documents
of the system's metacognitive state and reflections.
"""

import asyncio
import logging
from datetime import datetime
from pathlib import Path
from typing import Any, List, Optional

import httpx
from maximus_core_service.config import get_settings

logger = logging.getLogger(__name__)

settings = get_settings()
PROJECT_ROOT = settings.base_path.parent.parent.parent # Attempt to find Daimon root? Or hardcode?
# The code used hardcoded path earlier. Let's stick to simple.

PROJECT_ROOT = Path("/media/juan/DATA/projetos/Noesis/Daimon")
GEMINI_MD = PROJECT_ROOT / "data" / "journals" / "gemini.md"
CLAUDE_MD = PROJECT_ROOT / "data" / "journals" / "claude.md"

REFLECTOR_API_URL = "http://localhost:8001/v1/metacognitive/history"

class Journalor:
    """Updates system markdown journals from persistent memory."""
    
    def __init__(self):
        self._running = False
        self._task: Optional[asyncio.Task] = None
        
    async def start(self):
        """Start the journaling loop."""
        if self._running:
            return
        self._running = True
        self._task = asyncio.create_task(self._run_loop())
        logger.info("✍️ Journalor started - watching gemini.md/claude.md")

    async def stop(self):
        """Stop the journaling loop."""
        self._running = False
        if self._task:
            self._task.cancel()
            try:
                await self._task
            except asyncio.CancelledError:
                pass
            
    async def _run_loop(self):
        """Main update loop."""
        while self._running:
            try:
                await self._update_journals()
            except Exception as e:
                logger.error(f"Journalor error: {e}")
            
            # Update every 60 seconds
            await asyncio.sleep(60)
            
    async def _update_journals(self):
        """Fetch history and write to files."""
        history = await self._fetch_history()
        if not history:
            return
            
        self._write_gemini_md(history)
        self._write_claude_md(history)
        
    async def _fetch_history(self) -> List[dict[str, Any]]:
        """Fetch recent reflections from Reflector."""
        async with httpx.AsyncClient(timeout=10.0) as client:
            try:
                response = await client.get(REFLECTOR_API_URL, params={"limit": 10})
                if response.status_code == 200:
                    return response.json()
            except httpx.RequestError:
                pass
        return []

    def _write_gemini_md(self, history: List[dict[str, Any]]):
        """Update gemini.md with recent reflections."""
        content = ["# NOESIS System Journal (Gemini Perspective)\n"]
        content.append(f"> Last Updated: {datetime.now().isoformat()}\n")
        
        content.append("## Recent Reflections\n")
        
        for entry in history:
            ts = entry.get("timestamp", "")
            agent = entry.get("agent_id", "system")
            rtype = entry.get("reflection_type", "unknown")
            text = entry.get("content", "")
            
            content.append(f"### [{ts}] {rtype.upper()} on {agent}")
            content.append(f"{text}\n")
            
            verdict = entry.get("verdict")
            if verdict:
                score = verdict.get("quality_score", 0.0)
                checks = verdict.get("checks", [])
                passed = sum(1 for c in checks if c.get("passed"))
                total = len(checks)
                content.append(f"**Verdict**: Score {score:.2f} | Checks {passed}/{total}\n")
                
        content.append("\n---\n*Generated by Journalor Service*")
        
        try:
            GEMINI_MD.write_text("\n".join(content))
        except IOError as e:
            logger.error(f"Failed to write gemini.md: {e}")

    def _write_claude_md(self, history: List[dict[str, Any]]):
        """Update claude.md (Focus on specific insights)."""
        content = ["# NOESIS System Insights (Claude Perspective)\n"]
        content.append(f"> Last Updated: {datetime.now().isoformat()}\n")
        
        entries_with_insights = [e for e in history if "insight" in e.get("content", "").lower()]
        
        if not entries_with_insights:
             content.append("\n*No specific insights recorded recently.*\n")
        else:
            for entry in entries_with_insights:
                ts = entry.get("timestamp", "")
                text = entry.get("content", "")
                content.append(f"- **{ts}**: {text}")
                
        try:
            CLAUDE_MD.write_text("\n".join(content))
        except IOError as e:
            logger.error(f"Failed to write claude.md: {e}")
